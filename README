<GAME NAME> README
Cornerstone

CONTRIBUTORS
Akshay Srivatsan asrivat1@jhu.edu
Andrew Zhu azhu8@jhu.edu
Grady Xiao gxiao2@jhu.edu
Pratyush Trivedi ptrived8@jhu.edu

ASSIGNMENT 3 NOTES
This readme details the backend for all new features in this assignment

To compile and run, type the following:
cd src/
make
./gameManager

SCREENS

StartScreen
- Currently has our game production logo that fades in from black
- Also has our hero just walking to show progress and as something related
    to the game
- Switches to the menu screen in 10 secs

MenuScreen
- Has the options for play, adjust brightness, adjust volume, highscore, and quit
- The texts fade in from black and is centered horizontally
- Use SPACE to select options (currently SPACE is disabled for adjust
    brightness and adjust volume)

PlayScreen
- Has the game play
- Pressing Q will bring you back to the main menu.

HighscoreScreen
- Shows the highscore (fade in from black)
- Proceeds to the menu screen after 5 secs
- Pressing Q will bring you back to the main menu.

Press ESC at any time to quit the game. You can also select QUIT from the main
    menu.

ANIMATION
The hero and the enemy each have an AnimationComponent that will update
their sprites. If the character is moving at a velocity of more than 0.01,
we cycle through a four frame walking animation in the direction they are facing.
These frames are stored in the top row of the spritesheet. If the character is not
moving, we cycle through a two frame idle animation which is in the second row
of the spritesheet.


CLASS STRUCTURE

Entity
    This is a skeleton for any object that appears on the screen. To add
    functionality, various Components are attached to an Entity. The
    EntityBuilder is responsible for creating and destroying entities.

Handlers (aka. Systems)
    These objects handle entities, performing various functions depending on
    the entity's components. For example, the LocationHandler will look at
    each entity's current LocationComponent and PhysicsComponent to calculate
    where the entity should move to. Once these calculations are made, the
    Handler will update that Entity's LocationComponent and PhysicsComponent.
    Handlers can emit commands if they want another Handler to do something
    for them. ControlHandler is new, and handles changing states.

Components
    These define certain types of behavior for an entity. Their fields are used
    to determine how handlers interact with them. Some components can run
    complex functions to tell their handlers exactly what to do with them.
    The original components are now going to serve as base classes, so each
    type of component implements the same methods with inheritance.

Commands
    These are used to by Handlers to communicate with each other. Each handler
    handles a different set of commands.

GameManager
    The game manager maintains the game loop, all entities, and all commands.
    It is also responsible for startup and shutdown of the game.

GAMEPLAY

You are now a dude in a blue shirt. Maybe a TA? You are trying to dodge the
LAX bros who wander in a more sophisticated manner than last time. They now
independently pick a X and Y direction, so they can move diagonally. Your player
is also more sophisticated: you can accelerate in any direction. Hitting a wall
will reset your corresponding velocity direction. There is also some friction
so you will come to a stop if you stop inputting.

If your hero gets hit, an alarm noise will play.


QUIRKS
- no game name yet!
- crashing into walls resets your velocity to 0, but there is sometimes a lag
    when you try to move again in the opposite direction?
- idle state sometimes changes directions

TODOS
leaks?
rule of three
separate commandLists -> structure to do this?
separate componentLists
make sure abstract base classes are right for components
make Component classes virtual
Component has a passCommand() method?
